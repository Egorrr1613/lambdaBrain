## Рефлексия по заданию 8 
Описал в текстовом виде "грубую" версию алгоритма, за O(n^6). 
Первой идеей для оптимизации было при проходе по элементам матрицы исключать дублированный перебор подматриц
Например для матрицы:
```
123
456
789
```
при проходе по элементам матрицы в поисках подматриц пропускать элемет с координатами [0][2], 
так как образуемая от него подматрица [23][56] уже могла быть получена от элемента с координатами [0][1]

Так же при планировании алгоритма казалось что сумму элементов каждой подматрицы
можно посчитать не за O(n^2), а за o(1). Однако дальше продвинутся не получилось.
Ниже не законченный варинат алгоритма, который писал самостоятельно.
```
n -- ширина/высота
Проходим все двумерные матрицы
На второй итерации проходим все трехмерные матрицы

matrix -- матрица
size -- текущая размерность провеяемой матрицы
i -- координата проверяемой матрицы по оси x
j -- координата проверяемой матрицы по оси y
max_data -- кортеж, содеращий координаты максимальной матрицы и размер

Если i == n: возвращаем max_data

Пока j < n + size:
    Пока i < n + size:
        current_sum = 0
        s_iter = 0, счетчик для определения текущий размерности
        Пока s_iter < size:
            current_sum += matrix[j+size][i+size]
            if s == 0: continue
            current_sum += matrix[j][i+size]
            current_sum += matrix[j+size][i]
```
Дальше поспользовался гуглом.

Прочитал про [алгоритм Кадани](https://en.wikipedia.org/w/index.php?title=Maximum_subarray_problem&section=3#Kadane's_algorithm)
для поиска подмассива с наибольшей суммой и его адаптации для работы с матрицами.
Проанализировал алгоритм, реализовал вариант составления префиксного массива (массива сумм) как для одномерного массива так и для матрицы.

В ходе поиска материалов  наткнулся на [книжку](https://coollib.cc/b/659682-antti-laaksonen-olimpiadnoe-programmirovanie/read).
Начал ее изучение, показалось хорошим дополнительным источником информации.

Выводы:
1) Понял, что слабо понимаю понятие вспомогательной префиксной структуры. Решу дополнииельные задачи, для которых применяется схожий паттерн.
2) Не понимаю понятие динамического программирования и принцип оценки сложности алгоритма при использовании динамического программирования.
В тех статьях которые я прочитал в оценку сложности не входят циклы участвующие в формировании префиксной матрицы.
Эту часть просто выносят в отдельный метод и как будто бы не учитывают при оценке. Например [тут](https://www.geeksforgeeks.org/maximum-sum-submatrix/).
Этот момент так же дополнительно изучу.