## Рефлексия по заданию 7
Задание заставило подумать. Основная сложность возникла с тем, 
чтобы придумать альтернативу обходу всех элементов матрицы по кругу через задание границ 
и инкремент координат.

Прочитав ваше решение для 7 задания пришла в голову мысль в исходной матрице изменять 
пройденные элементы на False, вместо того, чтобы заводить отдельный массив.
Отбросил эту идею, так как концептуально ничего не меняется и 
изменение входных данных это плохой ход.

Затем пришла идея: "А что, если отталкиваться не от позиции в матрице, 
а от индекса элемента в конечном массиве?" 

Прикинул, действительно, такой "обратный расчет" от позиции элемента
в итоговом массиве к координатам элемента в матрице действительно работает.

Сел прописывать алгоритм, ниже привожу мой рабочий вариант, по которому потом писал код:

```
n -- ширина, m -- высота

Если индекс + 1 меньше или равен чем: ширина, тогда добавляем в массив элемент из 0[i]

Если индекс + 1 меньше чем: ширина + высота, то вычитаем из индекса ширину (n), 
    получаем h - индекс массива из матрицы, тоесть координату элемента по долготе
    добавляем элемент по индексу h[n - 1]

Если индекс меньше или равен: высота - 2 + 2 * ширина // (m - 2 + 2n), 
    тогда вычитаем из индекса 2*ширина + высоту - 2. Координата будет: n[result - i]
    
Если индекс меньше или равен (высота - 2)*2 + 2*ширина // (2(m - 2) + 2n), 
    тогда вычитаем из индекса 2*ширина + 2*(высоту - 2). Координата будет: result[0]
    
Иначе нужно сужать ось движения
```

Алгоритм сужения оси казался интуитивно понятным)
После того как прописал расчеты координаты относительно позиции,
думать над тем как прописать "сужение оси" категорически не хотелось. 
Естественно на реализации сужения я и потерял бОльшую часть времени при кодировании, 
допустил в этой части больше всего багов.

Правильно было бы взять перерыв и затем прописать алгоритм полностью.